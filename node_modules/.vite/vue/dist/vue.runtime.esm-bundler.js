import {
  shallowRef
} from "../../chunk.4FSH4LWU.js";
import {
  BaseTransition,
  Comment,
  Fragment,
  KeepAlive,
  Static,
  Suspense,
  Teleport,
  Text,
  Transition,
  TransitionGroup,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compile,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createHydrationRenderer,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  def,
  defineAsyncComponent,
  defineComponent,
  defineEmit,
  defineProps,
  devtools,
  getCurrentInstance,
  getTransitionRawChildren,
  h,
  handleError,
  hydrate,
  initCustomFormatter,
  inject,
  isArray,
  isMap,
  isObject,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isSet,
  isVNode,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  ssrContextKey,
  ssrUtils,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toTypeString,
  track,
  transformVNodeArgs,
  trigger,
  unref,
  useContext,
  useCssModule,
  useCssVars,
  useSSRContext,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers,
  withScopeId
} from "../../chunk.EY77OGAN.js";

// node_modules/@vue/shared/dist/shared.esm-bundler.js
var toDisplayString = (val) => {
  return val == null ? "" : isObject(val) ? JSON.stringify(val, replacer, 2) : String(val);
};
var replacer = (_key, val) => {
  if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
var isPlainObject = (val) => toTypeString(val) === "[object Object]";

// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
function triggerRef(ref2) {
  trigger(toRaw(ref2), "set", "value", true ? ref2.value : void 0);
}
var CustomRefImpl = class {
  constructor(factory) {
    this.__v_isRef = true;
    const {get, set} = factory(() => track(this, "get", "value"), () => trigger(this, "set", "value"));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
};
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if (!isProxy(object)) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
export {
  BaseTransition,
  Comment,
  Fragment,
  KeepAlive,
  Static,
  Suspense,
  Teleport,
  Text,
  Transition,
  TransitionGroup,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compile,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createHydrationRenderer,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineEmit,
  defineProps,
  devtools,
  getCurrentInstance,
  getTransitionRawChildren,
  h,
  handleError,
  hydrate,
  initCustomFormatter,
  inject,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isVNode,
  markRaw,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs,
  transformVNodeArgs,
  triggerRef,
  unref,
  useContext,
  useCssModule,
  useCssVars,
  useSSRContext,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers,
  withScopeId
};
//# sourceMappingURL=vue.runtime.esm-bundler.js.map
